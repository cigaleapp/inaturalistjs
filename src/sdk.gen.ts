// This file is auto-generated by @hey-api/openapi-ts

import { type Options as ClientOptions, type TDataShape, type Client, formDataBodySerializer } from '@hey-api/client-fetch';
import type { PostAnnotationsData, DeleteAnnotationsByIdData, PostVotesVoteAnnotationByIdData, DeleteVotesUnvoteAnnotationByIdData, PostCommentsData, DeleteCommentsByIdData, PutCommentsByIdData, GetControlledTermsData, GetControlledTermsForTaxonData, PostFlagsData, DeleteFlagsByIdData, PutFlagsByIdData, DeleteIdentificationsByIdData, GetIdentificationsByIdData, PutIdentificationsByIdData, GetIdentificationsData, PostIdentificationsData, GetIdentificationsCategoriesData, GetIdentificationsSpeciesCountsData, GetIdentificationsSpeciesCountsResponse, GetIdentificationsSpeciesCountsError, GetIdentificationsIdentifiersData, GetIdentificationsIdentifiersResponse, GetIdentificationsIdentifiersError, GetIdentificationsObserversData, GetIdentificationsObserversResponse, GetIdentificationsObserversError, GetIdentificationsRecentTaxaData, GetIdentificationsSimilarSpeciesData, GetMessagesData, GetMessagesError, PostMessagesData, PostMessagesResponse, PostMessagesError, DeleteMessagesByIdData, DeleteMessagesByIdError, GetMessagesByIdData, GetMessagesByIdResponse, GetMessagesByIdError, GetMessagesUnreadData, GetMessagesUnreadResponse, GetMessagesUnreadError, DeleteObservationsByIdData, GetObservationsByIdData, GetObservationsByIdResponse, GetObservationsByIdError, PutObservationsByIdData, PostObservationsByIdFaveData, DeleteObservationsByIdUnfaveData, DeleteObservationsByIdReviewData, PostObservationsByIdReviewData, GetObservationsByIdSubscriptionsData, DeleteObservationsByIdQualityByMetricData, PostObservationsByIdQualityByMetricData, GetObservationsByIdTaxonSummaryData, PostSubscriptionsObservationByIdSubscribeData, PostVotesVoteObservationByIdData, DeleteVotesUnvoteObservationByIdData, GetObservationsData, GetObservationsResponse, GetObservationsError, PostObservationsData, GetObservationsDeletedData, GetObservationsHistogramData, GetObservationsHistogramError, GetObservationsIdentifiersData, GetObservationsIdentifiersResponse, GetObservationsIdentifiersError, GetObservationsObserversData, GetObservationsObserversResponse, GetObservationsObserversError, GetObservationsPopularFieldValuesData, GetObservationsSpeciesCountsData, GetObservationsSpeciesCountsResponse, GetObservationsSpeciesCountsError, GetObservationsUpdatesData, PutObservationsByIdViewedUpdatesData, DeleteObservationFieldValuesByIdData, PutObservationFieldValuesByIdData, PostObservationFieldValuesData, DeleteObservationPhotosByIdData, PutObservationPhotosByIdData, PostObservationPhotosData, PostPhotosData, GetPlacesByIdData, GetPlacesByIdResponse, GetPlacesByIdError, GetPlacesAutocompleteData, GetPlacesAutocompleteResponse, GetPlacesAutocompleteError, GetPlacesNearbyData, GetPlacesNearbyResponse, GetPlacesNearbyError, GetPostsData, PostPostsData, DeletePostsByIdData, PutPostsByIdData, GetPostsForUserData, DeleteProjectObservationsByIdData, PutProjectObservationsByIdData, PostProjectObservationsData, GetProjectsData, GetProjectsResponse, GetProjectsError, GetProjectsByIdData, GetProjectsByIdResponse, GetProjectsByIdError, PostProjectsByIdJoinData, DeleteProjectsByIdLeaveData, GetProjectsByIdMembersData, GetProjectsByIdMembersResponse, GetProjectsByIdMembersError, GetProjectsByIdMembershipData, GetProjectsByIdSubscriptionsData, PostProjectsByIdAddData, DeleteProjectsByIdRemoveData, GetProjectsAutocompleteData, GetProjectsAutocompleteResponse, GetProjectsAutocompleteError, GetSearchData, PostSubscriptionsProjectByIdSubscribeData, GetTaxaByIdData, GetTaxaByIdResponse, GetTaxaByIdError, GetTaxaData, GetTaxaResponse, GetTaxaError, GetTaxaAutocompleteData, GetTaxaAutocompleteResponse, GetTaxaAutocompleteError, GetUsersByIdData, PutUsersByIdData, GetUsersByIdProjectsData, GetUsersAutocompleteData, GetUsersMeData, DeleteUsersByIdMuteData, PostUsersByIdMuteData, PostUsersResendConfirmationData, PutUsersUpdateSessionData, GetColoredHeatmapByZoomByXByYPngData, GetColoredHeatmapByZoomByXByYGridJsonData, GetColoredHeatmapByZoomByXByYGridJsonResponse, GetColoredHeatmapByZoomByXByYGridJsonError, GetGridByZoomByXByYPngData, GetGridByZoomByXByYGridJsonData, GetGridByZoomByXByYGridJsonResponse, GetGridByZoomByXByYGridJsonError, GetHeatmapByZoomByXByYPngData, GetHeatmapByZoomByXByYGridJsonData, GetHeatmapByZoomByXByYGridJsonResponse, GetHeatmapByZoomByXByYGridJsonError, GetPointsByZoomByXByYPngData, GetPointsByZoomByXByYGridJsonData, GetPointsByZoomByXByYGridJsonResponse, GetPointsByZoomByXByYGridJsonError, GetPlacesByPlaceIdByZoomByXByYPngData, GetTaxonPlacesByTaxonIdByZoomByXByYPngData, GetTaxonRangesByTaxonIdByZoomByXByYPngData } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Annotation Create
 * Create an annotation
 *
 */
export const postAnnotations = <ThrowOnError extends boolean = false>(options?: Options<PostAnnotationsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/annotations',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Annotation Delete
 * Delete an annotation
 *
 */
export const deleteAnnotationsById = <ThrowOnError extends boolean = false>(options: Options<DeleteAnnotationsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/annotations/{id}',
        ...options
    });
};

/**
 * Annotation Vote
 * Vote on an annotation
 *
 */
export const postVotesVoteAnnotationById = <ThrowOnError extends boolean = false>(options: Options<PostVotesVoteAnnotationByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/votes/vote/annotation/{id}',
        ...options
    });
};

/**
 * Annotation Unvote
 * Remove a vote from annotation
 *
 */
export const deleteVotesUnvoteAnnotationById = <ThrowOnError extends boolean = false>(options: Options<DeleteVotesUnvoteAnnotationByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/votes/unvote/annotation/{id}',
        ...options
    });
};

/**
 * Comment Create
 * Create a comment
 *
 */
export const postComments = <ThrowOnError extends boolean = false>(options?: Options<PostCommentsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/comments',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Comment Delete
 * Delete a comment
 *
 */
export const deleteCommentsById = <ThrowOnError extends boolean = false>(options: Options<DeleteCommentsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/comments/{id}',
        ...options
    });
};

/**
 * Comment Update
 * Update a comment
 *
 */
export const putCommentsById = <ThrowOnError extends boolean = false>(options: Options<PutCommentsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/comments/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Terms Index
 * List all attribute controlled terms
 *
 */
export const getControlledTerms = <ThrowOnError extends boolean = false>(options?: Options<GetControlledTermsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        url: '/controlled_terms',
        ...options
    });
};

/**
 * Terms for Taxon
 * Returns attribute controlled terms relevant to a taxon
 *
 */
export const getControlledTermsForTaxon = <ThrowOnError extends boolean = false>(options: Options<GetControlledTermsForTaxonData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        url: '/controlled_terms/for_taxon',
        ...options
    });
};

/**
 * Flag Create
 * Create a flag. To create a custom flag beyond the standard `spam` and
 * `inappropriate` flags, set `flag` to `other` and include a `flag_explanation`
 *
 */
export const postFlags = <ThrowOnError extends boolean = false>(options?: Options<PostFlagsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/flags',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Flag Delete
 * Delete a flag
 *
 */
export const deleteFlagsById = <ThrowOnError extends boolean = false>(options: Options<DeleteFlagsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/flags/{id}',
        ...options
    });
};

/**
 * Flag Update
 * Update a flag. Generally only used to resolve the flag.
 *
 */
export const putFlagsById = <ThrowOnError extends boolean = false>(options: Options<PutFlagsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/flags/{id}',
        ...options
    });
};

/**
 * Identification Delete
 * Delete an identification. See description of `PUT /identifications/{id}
 * for notes on withdrawing and restoring identifications.
 *
 */
export const deleteIdentificationsById = <ThrowOnError extends boolean = false>(options: Options<DeleteIdentificationsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/identifications/{id}',
        ...options
    });
};

/**
 * Identification Details
 * Given an ID, or an array of IDs in comma-delimited format, returns
 * corresponding identifications. A maximum of 30 results will be returned
 *
 */
export const getIdentificationsById = <ThrowOnError extends boolean = false>(options: Options<GetIdentificationsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        url: '/identifications/{id}',
        ...options
    });
};

/**
 * Identification Update
 * Update an identification. Note that to "withdraw" an observation you
 * send a `PUT` request to this endpoint and set the `current`
 * attribute to false. To "restore" it you do the same but set
 * `current` to `true`. Only one identification by a given user can be
 * `current` for a given observation, so if you "restore" one all the other
 * identifications by the authenticated user for the given observation will
 * be withdrawn.
 *
 */
export const putIdentificationsById = <ThrowOnError extends boolean = false>(options: Options<PutIdentificationsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/identifications/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Identification Search
 * Given zero to many of following parameters, returns identifications
 * matching the search criteria
 *
 */
export const getIdentifications = <ThrowOnError extends boolean = false>(options?: Options<GetIdentificationsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/identifications',
        ...options
    });
};

/**
 * Identification Create
 * Create an identification
 */
export const postIdentifications = <ThrowOnError extends boolean = false>(options?: Options<PostIdentificationsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/identifications',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Identification Categories
 * Given zero to many of following parameters, return counts of the
 * categories of identifications matching the search criteria
 *
 */
export const getIdentificationsCategories = <ThrowOnError extends boolean = false>(options?: Options<GetIdentificationsCategoriesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/identifications/categories',
        ...options
    });
};

/**
 * Identification Species Counts
 * Given zero to many of following parameters, returns `leaf taxa`
 * associated with identifications matching the search criteria and the
 * count of identifications they are associated with, ordered by count
 * descending. `Leaf taxa` are the leaves of the taxonomic tree containing
 * only the taxa associated with observations matching the search criteria.
 *
 */
export const getIdentificationsSpeciesCounts = <ThrowOnError extends boolean = false>(options?: Options<GetIdentificationsSpeciesCountsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetIdentificationsSpeciesCountsResponse, GetIdentificationsSpeciesCountsError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/identifications/species_counts',
        ...options
    });
};

/**
 * Identification Identifiers
 * Given zero to many of following parameters, returns creators of
 * identifications matching the search criteria and the count of
 * matching identifications, ordered by count descending. A
 * maximum of 500 results will be returned
 *
 */
export const getIdentificationsIdentifiers = <ThrowOnError extends boolean = false>(options?: Options<GetIdentificationsIdentifiersData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetIdentificationsIdentifiersResponse, GetIdentificationsIdentifiersError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/identifications/identifiers',
        ...options
    });
};

/**
 * Identification Observers
 * Given zero to many of following parameters, returns creators of
 * observations of identifications matching the search criteria and
 * the count of matching observations, ordered by count descending
 *
 */
export const getIdentificationsObservers = <ThrowOnError extends boolean = false>(options?: Options<GetIdentificationsObserversData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetIdentificationsObserversResponse, GetIdentificationsObserversError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/identifications/observers',
        ...options
    });
};

/**
 * Identification Recent Taxa
 * Returns an array of objects each containing an identification and a
 * taxon. Returns IDs representing the earliest occurrence of taxa
 * associated with identifications in the filtered set of results
 *
 */
export const getIdentificationsRecentTaxa = <ThrowOnError extends boolean = false>(options?: Options<GetIdentificationsRecentTaxaData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/identifications/recent_taxa',
        ...options
    });
};

/**
 * Identification Similar Species
 * Returns species attached to IDs of observations of this taxon, or
 * attached to observations identified as this species, ordered by combined
 * frequency descending. This will only return species in the same iconic
 * taxon, and will never return descendants of the chosen taxon
 *
 */
export const getIdentificationsSimilarSpecies = <ThrowOnError extends boolean = false>(options: Options<GetIdentificationsSimilarSpeciesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/identifications/similar_species',
        ...options
    });
};

/**
 * Retrieve messages for the authenticated user. This does not mark them as read.
 * Show the user's inbox or sent box
 */
export const getMessages = <ThrowOnError extends boolean = false>(options?: Options<GetMessagesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, GetMessagesError, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/messages',
        ...options
    });
};

/**
 * Create a new message
 * Create and deliver a new message to another user
 */
export const postMessages = <ThrowOnError extends boolean = false>(options?: Options<PostMessagesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<PostMessagesResponse, PostMessagesError, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/messages',
        ...options
    });
};

/**
 * Delete a message / thread
 * This will all of the authenticated user's copies of the messages in tha
 * thread to which the specified message belongs.
 *
 */
export const deleteMessagesById = <ThrowOnError extends boolean = false>(options: Options<DeleteMessagesByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, DeleteMessagesByIdError, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/messages/{id}',
        ...options
    });
};

/**
 * Retrieve messages in a thread
 * Retrieves all messages in the thread the specified message belongs to
 * and marks them all as read.
 *
 */
export const getMessagesById = <ThrowOnError extends boolean = false>(options: Options<GetMessagesByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetMessagesByIdResponse, GetMessagesByIdError, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/messages/{id}',
        ...options
    });
};

/**
 * Gets a count of messages the authenticated user has not read
 */
export const getMessagesUnread = <ThrowOnError extends boolean = false>(options?: Options<GetMessagesUnreadData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetMessagesUnreadResponse, GetMessagesUnreadError, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/messages/unread',
        ...options
    });
};

/**
 * Observation Delete
 * Delete an observation
 *
 */
export const deleteObservationsById = <ThrowOnError extends boolean = false>(options: Options<DeleteObservationsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observations/{id}',
        ...options
    });
};

/**
 * Observation Details
 * Given an ID, or an array of IDs in comma-delimited format, returns
 * corresponding observations. A maximum of 200 results will be returned
 *
 */
export const getObservationsById = <ThrowOnError extends boolean = false>(options: Options<GetObservationsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetObservationsByIdResponse, GetObservationsByIdError, ThrowOnError>({
        url: '/observations/{id}',
        ...options
    });
};

/**
 * Observation Update
 * Update an observation
 *
 */
export const putObservationsById = <ThrowOnError extends boolean = false>(options: Options<PutObservationsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observations/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Observations Fave
 * Fave an observation
 *
 */
export const postObservationsByIdFave = <ThrowOnError extends boolean = false>(options: Options<PostObservationsByIdFaveData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observations/{id}/fave',
        ...options
    });
};

/**
 * Observations Unfave
 * Unfave an observation
 *
 */
export const deleteObservationsByIdUnfave = <ThrowOnError extends boolean = false>(options: Options<DeleteObservationsByIdUnfaveData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observations/{id}/unfave',
        ...options
    });
};

/**
 * Observations Unreview
 * Unreview an observation
 *
 */
export const deleteObservationsByIdReview = <ThrowOnError extends boolean = false>(options: Options<DeleteObservationsByIdReviewData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observations/{id}/review',
        ...options
    });
};

/**
 * Observations Review
 * Review an observation
 *
 */
export const postObservationsByIdReview = <ThrowOnError extends boolean = false>(options: Options<PostObservationsByIdReviewData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observations/{id}/review',
        ...options
    });
};

/**
 * Observation Subscriptions
 * Fetches any subscriptions the current user has to this observation
 * or the observer
 *
 */
export const getObservationsByIdSubscriptions = <ThrowOnError extends boolean = false>(options: Options<GetObservationsByIdSubscriptionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observations/{id}/subscriptions',
        ...options
    });
};

/**
 * Quality Metric Delete
 * Delete a quality metric
 *
 */
export const deleteObservationsByIdQualityByMetric = <ThrowOnError extends boolean = false>(options: Options<DeleteObservationsByIdQualityByMetricData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observations/{id}/quality/{metric}',
        ...options
    });
};

/**
 * Quality Metric Set
 * Set the value of a quality metric
 *
 */
export const postObservationsByIdQualityByMetric = <ThrowOnError extends boolean = false>(options: Options<PostObservationsByIdQualityByMetricData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observations/{id}/quality/{metric}',
        ...options
    });
};

/**
 * Observation Taxon Summary
 * Fetches information about this observation's taxon, within the context
 * of this observation's location
 *
 */
export const getObservationsByIdTaxonSummary = <ThrowOnError extends boolean = false>(options: Options<GetObservationsByIdTaxonSummaryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        url: '/observations/{id}/taxon_summary',
        ...options
    });
};

/**
 * Observation Subscribe
 * Toggles current user's subscription to this observation. If the logged-in
 * user is not subscribed, POSTing here will subscribe them. If they are already
 * subscribed, this will remove the subscription
 *
 */
export const postSubscriptionsObservationByIdSubscribe = <ThrowOnError extends boolean = false>(options: Options<PostSubscriptionsObservationByIdSubscribeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/subscriptions/observation/{id}/subscribe',
        ...options
    });
};

/**
 * Observation Vote
 * Vote on an observation. A vote with an empty `scope` is recorded as a
 * `fave` of the observation. A vote with scope `needs_id` is recorded as a
 * vote on the Quality Grade criterion "can the Community ID still be
 * confirmed or improved?", and can be an up or down vote
 *
 */
export const postVotesVoteObservationById = <ThrowOnError extends boolean = false>(options: Options<PostVotesVoteObservationByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/votes/vote/observation/{id}',
        ...options
    });
};

/**
 * Observation Unvote
 * Remove a vote from an observation
 */
export const deleteVotesUnvoteObservationById = <ThrowOnError extends boolean = false>(options: Options<DeleteVotesUnvoteObservationByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/votes/unvote/observation/{id}',
        ...options
    });
};

/**
 * Observation Search
 * Given zero to many of following parameters, returns observations
 * matching the search criteria. The large size of the observations index
 * prevents us from supporting the `page` parameter when retrieving records
 * from large result sets. If you need to retrieve large numbers of
 * records, use the `per_page` and `id_above` or `id_below` parameters
 * instead.
 *
 */
export const getObservations = <ThrowOnError extends boolean = false>(options?: Options<GetObservationsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetObservationsResponse, GetObservationsError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/observations',
        ...options
    });
};

/**
 * Observation Create
 * Create an observation
 *
 */
export const postObservations = <ThrowOnError extends boolean = false>(options?: Options<PostObservationsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observations',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Observations Deleted
 * Given a starting date, return an array of IDs of the authenticated
 * user's observations that have been deleted since that date. Requires
 * authentication
 *
 */
export const getObservationsDeleted = <ThrowOnError extends boolean = false>(options: Options<GetObservationsDeletedData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observations/deleted',
        ...options
    });
};

/**
 * Observation Histogram
 * Given zero to many of following parameters, returns histogram data about
 * observations matching the search criteria
 *
 */
export const getObservationsHistogram = <ThrowOnError extends boolean = false>(options?: Options<GetObservationsHistogramData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, GetObservationsHistogramError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/observations/histogram',
        ...options
    });
};

/**
 * Observation Identifiers
 * Given zero to many of following parameters, returns identifiers of
 * observations matching the search criteria and the count of
 * observations they have identified, ordered by count descending. A
 * maximum of 500 results will be returned
 *
 */
export const getObservationsIdentifiers = <ThrowOnError extends boolean = false>(options?: Options<GetObservationsIdentifiersData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetObservationsIdentifiersResponse, GetObservationsIdentifiersError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/observations/identifiers',
        ...options
    });
};

/**
 * Observation Observers
 * Given zero to many of following parameters, returns observers of
 * observations matching the search criteria and the count of
 * observations and distinct taxa of rank `species` they have observed. A
 * maximum of 500 results will be returned
 *
 */
export const getObservationsObservers = <ThrowOnError extends boolean = false>(options?: Options<GetObservationsObserversData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetObservationsObserversResponse, GetObservationsObserversError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/observations/observers',
        ...options
    });
};

/**
 * Observation Popular Field Values
 * Given zero to many of following parameters, returns an array of
 * relevant controlled terms values and a monthly histogram
 *
 */
export const getObservationsPopularFieldValues = <ThrowOnError extends boolean = false>(options?: Options<GetObservationsPopularFieldValuesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/observations/popular_field_values',
        ...options
    });
};

/**
 * Observation Species Counts
 * Given zero to many of following parameters, returns `leaf taxa`
 * associated with observations matching the search criteria and the count of
 * observations they are associated with, ordered by count descending.
 * `Leaf taxa` are the leaves of the taxonomic tree containing only the
 * taxa associated with observations matching the search criteria.
 *
 */
export const getObservationsSpeciesCounts = <ThrowOnError extends boolean = false>(options?: Options<GetObservationsSpeciesCountsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetObservationsSpeciesCountsResponse, GetObservationsSpeciesCountsError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/observations/species_counts',
        ...options
    });
};

/**
 * Observation User Updates
 * Given zero to many of following parameters, returns an array of objects
 * representing new comments and identifications on observations the authenticated
 * user has subscribed to. Requires authentication
 *
 */
export const getObservationsUpdates = <ThrowOnError extends boolean = false>(options?: Options<GetObservationsUpdatesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observations/updates',
        ...options
    });
};

/**
 * Observation Field Value Update
 * Mark all updates associated with this observation as viewed by logged-in user
 *
 */
export const putObservationsByIdViewedUpdates = <ThrowOnError extends boolean = false>(options: Options<PutObservationsByIdViewedUpdatesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observations/{id}/viewed_updates',
        ...options
    });
};

/**
 * Observation Field Value Delete
 * Delete an observation field value
 *
 */
export const deleteObservationFieldValuesById = <ThrowOnError extends boolean = false>(options: Options<DeleteObservationFieldValuesByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observation_field_values/{id}',
        ...options
    });
};

/**
 * Observation Field Value Update
 * Update an observation field value
 *
 */
export const putObservationFieldValuesById = <ThrowOnError extends boolean = false>(options: Options<PutObservationFieldValuesByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observation_field_values/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Observation Field Value Create
 * Create an observation field value
 *
 */
export const postObservationFieldValues = <ThrowOnError extends boolean = false>(options?: Options<PostObservationFieldValuesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observation_field_values',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Observation Photo Delete
 * Delete an observation photo
 *
 */
export const deleteObservationPhotosById = <ThrowOnError extends boolean = false>(options: Options<DeleteObservationPhotosByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observation_photos/{id}',
        ...options
    });
};

/**
 * Observation Photo Update
 * Update an observation photo
 */
export const putObservationPhotosById = <ThrowOnError extends boolean = false>(options: Options<PutObservationPhotosByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<unknown, unknown, ThrowOnError>({
        ...formDataBodySerializer,
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observation_photos/{id}',
        ...options,
        headers: {
            'Content-Type': null,
            ...options?.headers
        }
    });
};

/**
 * Observation Photo Create
 * Create an observation photo
 *
 */
export const postObservationPhotos = <ThrowOnError extends boolean = false>(options?: Options<PostObservationPhotosData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        ...formDataBodySerializer,
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/observation_photos',
        ...options,
        headers: {
            'Content-Type': null,
            ...options?.headers
        }
    });
};

/**
 * Photo Create
 * Create a photo
 *
 */
export const postPhotos = <ThrowOnError extends boolean = false>(options?: Options<PostPhotosData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        ...formDataBodySerializer,
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/photos',
        ...options,
        headers: {
            'Content-Type': null,
            ...options?.headers
        }
    });
};

/**
 * Place Details
 * Given an ID, or an array of IDs in comma-delimited format, returns
 * corresponding places. A maximum of 500 results will be returned
 *
 */
export const getPlacesById = <ThrowOnError extends boolean = false>(options: Options<GetPlacesByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetPlacesByIdResponse, GetPlacesByIdError, ThrowOnError>({
        url: '/places/{id}',
        ...options
    });
};

/**
 * Place Autocomplete
 * Given an string, returns places with names starting with the search
 * term.
 *
 */
export const getPlacesAutocomplete = <ThrowOnError extends boolean = false>(options: Options<GetPlacesAutocompleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetPlacesAutocompleteResponse, GetPlacesAutocompleteError, ThrowOnError>({
        url: '/places/autocomplete',
        ...options
    });
};

/**
 * Nearby Places
 * Given an bounding box, and an optional name query, return `standard`
 * iNaturalist curator approved and `community` non-curated places nearby
 *
 */
export const getPlacesNearby = <ThrowOnError extends boolean = false>(options: Options<GetPlacesNearbyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetPlacesNearbyResponse, GetPlacesNearbyError, ThrowOnError>({
        url: '/places/nearby',
        ...options
    });
};

/**
 * Posts Search
 * Return journal posts from the iNaturalist site
 *
 */
export const getPosts = <ThrowOnError extends boolean = false>(options?: Options<GetPostsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/posts',
        ...options
    });
};

/**
 * Post Create
 * Create a post
 *
 */
export const postPosts = <ThrowOnError extends boolean = false>(options?: Options<PostPostsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/posts',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Post Delete
 * Delete a post
 *
 */
export const deletePostsById = <ThrowOnError extends boolean = false>(options: Options<DeletePostsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/posts/{id}',
        ...options
    });
};

/**
 * Post Update
 * Update a post
 *
 */
export const putPostsById = <ThrowOnError extends boolean = false>(options: Options<PutPostsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/posts/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Posts For User
 * Return journal posts from the iNaturalist site. If the user is logged-in,
 * also return posts from projects the user is subscribed to
 *
 */
export const getPostsForUser = <ThrowOnError extends boolean = false>(options?: Options<GetPostsForUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/posts/for_user',
        ...options
    });
};

/**
 * Project Observation Delete
 * Delete a project observation
 */
export const deleteProjectObservationsById = <ThrowOnError extends boolean = false>(options: Options<DeleteProjectObservationsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/project_observations/{id}',
        ...options
    });
};

/**
 * Project Observation Update
 * Update a project observation
 */
export const putProjectObservationsById = <ThrowOnError extends boolean = false>(options: Options<PutProjectObservationsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/project_observations/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Project Observation Create
 * Add an observation to a project
 */
export const postProjectObservations = <ThrowOnError extends boolean = false>(options?: Options<PostProjectObservationsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/project_observations',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Project Search
 * Given zero to many of following parameters, returns projects
 * matching the search criteria
 *
 */
export const getProjects = <ThrowOnError extends boolean = false>(options?: Options<GetProjectsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetProjectsResponse, GetProjectsError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/projects',
        ...options
    });
};

/**
 * Project Details
 * Given an ID, or an array of IDs in comma-delimited format, returns
 * corresponding projects. A maximum of 100 results will be returned
 *
 */
export const getProjectsById = <ThrowOnError extends boolean = false>(options: Options<GetProjectsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetProjectsByIdResponse, GetProjectsByIdError, ThrowOnError>({
        url: '/projects/{id}',
        ...options
    });
};

/**
 * Projects Join
 * Join a project
 *
 */
export const postProjectsByIdJoin = <ThrowOnError extends boolean = false>(options: Options<PostProjectsByIdJoinData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{id}/join',
        ...options
    });
};

/**
 * Projects Leave
 * Leave a project
 *
 */
export const deleteProjectsByIdLeave = <ThrowOnError extends boolean = false>(options: Options<DeleteProjectsByIdLeaveData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{id}/leave',
        ...options
    });
};

/**
 * Project Members
 * Given an ID, return members of the project
 *
 */
export const getProjectsByIdMembers = <ThrowOnError extends boolean = false>(options: Options<GetProjectsByIdMembersData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetProjectsByIdMembersResponse, GetProjectsByIdMembersError, ThrowOnError>({
        url: '/projects/{id}/members',
        ...options
    });
};

/**
 * Membership of current user
 * Given an ID, or an array of IDs in comma-delimited format, return the details of the
 * authenticated user's membership in these projects
 *
 */
export const getProjectsByIdMembership = <ThrowOnError extends boolean = false>(options: Options<GetProjectsByIdMembershipData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{id}/membership',
        ...options
    });
};

/**
 * @deprecated
 * Project Subscriptions
 * [Deprecated] Subscriptions to projects are managed through joining and
 * leaving projects, so this will not return any useful information.
 *
 * Given an ID, return subscription of the current user
 *
 */
export const getProjectsByIdSubscriptions = <ThrowOnError extends boolean = false>(options: Options<GetProjectsByIdSubscriptionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{id}/subscriptions',
        ...options
    });
};

/**
 * Project Add
 * Add an observation to a project
 */
export const postProjectsByIdAdd = <ThrowOnError extends boolean = false>(options: Options<PostProjectsByIdAddData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{id}/add',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Project Add
 * Remove an observation from a project
 */
export const deleteProjectsByIdRemove = <ThrowOnError extends boolean = false>(options: Options<DeleteProjectsByIdRemoveData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{id}/remove',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Project Autocomplete
 * Given an string, returns projects with titles starting with the search term
 *
 */
export const getProjectsAutocomplete = <ThrowOnError extends boolean = false>(options: Options<GetProjectsAutocompleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetProjectsAutocompleteResponse, GetProjectsAutocompleteError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/projects/autocomplete',
        ...options
    });
};

/**
 * Site Search
 * Given zero to many of following parameters, returns object matching the search criteria
 *
 */
export const getSearch = <ThrowOnError extends boolean = false>(options?: Options<GetSearchData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/search',
        ...options
    });
};

/**
 * Project Subscribe
 * Toggles current user's subscription to this project. If the logged-in
 * user is not subscribed, POSTing here will subscribe them. If they are already
 * subscribed, this will remove the subscription
 *
 */
export const postSubscriptionsProjectByIdSubscribe = <ThrowOnError extends boolean = false>(options: Options<PostSubscriptionsProjectByIdSubscribeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/subscriptions/project/{id}/subscribe',
        ...options
    });
};

/**
 * Taxon Details
 * Given an ID, or an array of IDs in comma-delimited format, returns
 * corresponding taxa. A maximum of 30 results will be returned
 *
 */
export const getTaxaById = <ThrowOnError extends boolean = false>(options: Options<GetTaxaByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetTaxaByIdResponse, GetTaxaByIdError, ThrowOnError>({
        url: '/taxa/{id}',
        ...options
    });
};

/**
 * Taxon Search
 * Given zero to many of following parameters, returns taxa matching the search criteria
 *
 */
export const getTaxa = <ThrowOnError extends boolean = false>(options?: Options<GetTaxaData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetTaxaResponse, GetTaxaError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/taxa',
        ...options
    });
};

/**
 * Taxon Autocomplete
 * Given an string, returns taxa with names starting with the search term
 *
 */
export const getTaxaAutocomplete = <ThrowOnError extends boolean = false>(options: Options<GetTaxaAutocompleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetTaxaAutocompleteResponse, GetTaxaAutocompleteError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/taxa/autocomplete',
        ...options
    });
};

/**
 * User Details
 * Given an ID, returns corresponding user
 */
export const getUsersById = <ThrowOnError extends boolean = false>(options: Options<GetUsersByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        url: '/users/{id}',
        ...options
    });
};

/**
 * User Update
 * Update a user
 *
 */
export const putUsersById = <ThrowOnError extends boolean = false>(options: Options<PutUsersByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/{id}',
        ...options
    });
};

/**
 * User Projects
 * Return projects as user has joined / followed
 *
 */
export const getUsersByIdProjects = <ThrowOnError extends boolean = false>(options: Options<GetUsersByIdProjectsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        url: '/users/{id}/projects',
        ...options
    });
};

/**
 * User Autocomplete
 * Given an string, returns users with names or logins starting with the search term
 *
 */
export const getUsersAutocomplete = <ThrowOnError extends boolean = false>(options: Options<GetUsersAutocompleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        url: '/users/autocomplete',
        ...options
    });
};

/**
 * Users Me
 * Fetch the logged-in user
 */
export const getUsersMe = <ThrowOnError extends boolean = false>(options?: Options<GetUsersMeData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/me',
        ...options
    });
};

/**
 * Unmute a User
 * Remove a mute on the user specified by {id}
 */
export const deleteUsersByIdMute = <ThrowOnError extends boolean = false>(options: Options<DeleteUsersByIdMuteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/{id}/mute',
        ...options
    });
};

/**
 * Mute a User
 * Make it so the authenticated user stops receiving notifications about
 * activity by the user specified by {id}.
 *
 */
export const postUsersByIdMute = <ThrowOnError extends boolean = false>(options: Options<PostUsersByIdMuteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/{id}/mute',
        ...options
    });
};

/**
 * User Resend Confirmation
 * Resend an email confirmation
 */
export const postUsersResendConfirmation = <ThrowOnError extends boolean = false>(options?: Options<PostUsersResendConfirmationData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/resend_confirmation',
        ...options
    });
};

/**
 * User Update Session
 * Update the logged-in user's session
 */
export const putUsersUpdateSession = <ThrowOnError extends boolean = false>(options?: Options<PutUsersUpdateSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).put<unknown, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/update_session',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Colored Heatmap Tiles
 * Given zero to many of following parameters, returns a PNG image
 * representing the matching observations within a map tile, following
 * the XYZ tiling scheme
 *
 */
export const getColoredHeatmapByZoomByXByYPng = <ThrowOnError extends boolean = false>(options: Options<GetColoredHeatmapByZoomByXByYPngData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/colored_heatmap/{zoom}/{x}/{y}.png',
        ...options
    });
};

/**
 * Colored Heatmap Tiles UTFGrid
 * Given zero to many of following parameters, returns a JSON file
 * following the UTFGrid spec, representing observations matching
 * the search criteria
 *
 */
export const getColoredHeatmapByZoomByXByYGridJson = <ThrowOnError extends boolean = false>(options: Options<GetColoredHeatmapByZoomByXByYGridJsonData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetColoredHeatmapByZoomByXByYGridJsonResponse, GetColoredHeatmapByZoomByXByYGridJsonError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/colored_heatmap/{zoom}/{x}/{y}.grid.json',
        ...options
    });
};

/**
 * Grid Tiles
 * Given zero to many of following parameters, returns a PNG image
 * representing the matching observations within a map tile, following
 * the XYZ tiling scheme
 *
 */
export const getGridByZoomByXByYPng = <ThrowOnError extends boolean = false>(options: Options<GetGridByZoomByXByYPngData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/grid/{zoom}/{x}/{y}.png',
        ...options
    });
};

/**
 * Grid Tiles UTFGrid
 * Given zero to many of following parameters, returns a JSON file
 * following the UTFGrid spec, representing observations matching
 * the search criteria
 *
 */
export const getGridByZoomByXByYGridJson = <ThrowOnError extends boolean = false>(options: Options<GetGridByZoomByXByYGridJsonData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGridByZoomByXByYGridJsonResponse, GetGridByZoomByXByYGridJsonError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/grid/{zoom}/{x}/{y}.grid.json',
        ...options
    });
};

/**
 * Heatmap Tiles
 * Given zero to many of following parameters, returns a PNG image
 * representing the matching observations within a map tile, following
 * the XYZ tiling scheme
 *
 */
export const getHeatmapByZoomByXByYPng = <ThrowOnError extends boolean = false>(options: Options<GetHeatmapByZoomByXByYPngData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/heatmap/{zoom}/{x}/{y}.png',
        ...options
    });
};

/**
 * Heatmap Tiles UTFGrid
 * Given zero to many of following parameters, returns a JSON file
 * following the UTFGrid spec, representing observations matching
 * the search criteria
 *
 */
export const getHeatmapByZoomByXByYGridJson = <ThrowOnError extends boolean = false>(options: Options<GetHeatmapByZoomByXByYGridJsonData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetHeatmapByZoomByXByYGridJsonResponse, GetHeatmapByZoomByXByYGridJsonError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/heatmap/{zoom}/{x}/{y}.grid.json',
        ...options
    });
};

/**
 * Points Tiles
 * Given zero to many of following parameters, returns a PNG image
 * representing the matching observations within a map tile, following
 * the XYZ tiling scheme
 *
 */
export const getPointsByZoomByXByYPng = <ThrowOnError extends boolean = false>(options: Options<GetPointsByZoomByXByYPngData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/points/{zoom}/{x}/{y}.png',
        ...options
    });
};

/**
 * Points Tiles UTFGrid
 * Given zero to many of following parameters, returns a JSON file
 * following the UTFGrid spec, representing observations matching
 * the search criteria
 *
 */
export const getPointsByZoomByXByYGridJson = <ThrowOnError extends boolean = false>(options: Options<GetPointsByZoomByXByYGridJsonData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetPointsByZoomByXByYGridJsonResponse, GetPointsByZoomByXByYGridJsonError, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/points/{zoom}/{x}/{y}.grid.json',
        ...options
    });
};

/**
 * Place Tiles
 * Returns a PNG map tile representing the boundary of this place,
 * following the XYZ tiling scheme
 *
 */
export const getPlacesByPlaceIdByZoomByXByYPng = <ThrowOnError extends boolean = false>(options: Options<GetPlacesByPlaceIdByZoomByXByYPngData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        url: '/places/{place_id}/{zoom}/{x}/{y}.png',
        ...options
    });
};

/**
 * Taxon Place Tiles
 * Returns a PNG map tile representing the boundaries of places this taxon
 * is known to occur, following the XYZ tiling scheme
 *
 */
export const getTaxonPlacesByTaxonIdByZoomByXByYPng = <ThrowOnError extends boolean = false>(options: Options<GetTaxonPlacesByTaxonIdByZoomByXByYPngData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        url: '/taxon_places/{taxon_id}/{zoom}/{x}/{y}.png',
        ...options
    });
};

/**
 * Taxon Range Tiles
 * Returns a PNG map tile representing the range of this taxon, following
 * the XYZ tiling scheme
 *
 */
export const getTaxonRangesByTaxonIdByZoomByXByYPng = <ThrowOnError extends boolean = false>(options: Options<GetTaxonRangesByTaxonIdByZoomByXByYPngData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        url: '/taxon_ranges/{taxon_id}/{zoom}/{x}/{y}.png',
        ...options
    });
};